// Code generated by protoc-gen-srpc. DO NOT EDIT.
// protoc-gen-srpc version: v0.31.12
// source: github.com/aperturerobotics/protobuf-project/example/other/other.proto

package other

import (
	context "context"

	srpc "github.com/aperturerobotics/starpc/srpc"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

type SRPCAccessVolumesClient interface {
	SRPCClient() srpc.Client

	WatchVolumeInfo(ctx context.Context, in *emptypb.Empty) (*emptypb.Empty, error)
}

type srpcAccessVolumesClient struct {
	cc        srpc.Client
	serviceID string
}

func NewSRPCAccessVolumesClient(cc srpc.Client) SRPCAccessVolumesClient {
	return &srpcAccessVolumesClient{cc: cc, serviceID: SRPCAccessVolumesServiceID}
}

func NewSRPCAccessVolumesClientWithServiceID(cc srpc.Client, serviceID string) SRPCAccessVolumesClient {
	if serviceID == "" {
		serviceID = SRPCAccessVolumesServiceID
	}
	return &srpcAccessVolumesClient{cc: cc, serviceID: serviceID}
}

func (c *srpcAccessVolumesClient) SRPCClient() srpc.Client { return c.cc }

func (c *srpcAccessVolumesClient) WatchVolumeInfo(ctx context.Context, in *emptypb.Empty) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.ExecCall(ctx, c.serviceID, "WatchVolumeInfo", in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type SRPCAccessVolumesServer interface {
	WatchVolumeInfo(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
}

type SRPCAccessVolumesUnimplementedServer struct{}

func (s *SRPCAccessVolumesUnimplementedServer) WatchVolumeInfo(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, srpc.ErrUnimplemented
}

const SRPCAccessVolumesServiceID = "other.AccessVolumes"

type SRPCAccessVolumesHandler struct {
	serviceID string
	impl      SRPCAccessVolumesServer
}

// NewSRPCAccessVolumesHandler constructs a new RPC handler.
// serviceID: if empty, uses default: other.AccessVolumes
func NewSRPCAccessVolumesHandler(impl SRPCAccessVolumesServer, serviceID string) srpc.Handler {
	if serviceID == "" {
		serviceID = SRPCAccessVolumesServiceID
	}
	return &SRPCAccessVolumesHandler{impl: impl, serviceID: serviceID}
}

// SRPCRegisterAccessVolumes registers the implementation with the mux.
// Uses the default serviceID: other.AccessVolumes
func SRPCRegisterAccessVolumes(mux srpc.Mux, impl SRPCAccessVolumesServer) error {
	return mux.Register(NewSRPCAccessVolumesHandler(impl, ""))
}

func (d *SRPCAccessVolumesHandler) GetServiceID() string { return d.serviceID }

func (SRPCAccessVolumesHandler) GetMethodIDs() []string {
	return []string{
		"WatchVolumeInfo",
	}
}

func (d *SRPCAccessVolumesHandler) InvokeMethod(
	serviceID, methodID string,
	strm srpc.Stream,
) (bool, error) {
	if serviceID != "" && serviceID != d.GetServiceID() {
		return false, nil
	}

	switch methodID {
	case "WatchVolumeInfo":
		return true, d.InvokeMethod_WatchVolumeInfo(d.impl, strm)
	default:
		return false, nil
	}
}

func (SRPCAccessVolumesHandler) InvokeMethod_WatchVolumeInfo(impl SRPCAccessVolumesServer, strm srpc.Stream) error {
	req := new(emptypb.Empty)
	if err := strm.MsgRecv(req); err != nil {
		return err
	}
	out, err := impl.WatchVolumeInfo(strm.Context(), req)
	if err != nil {
		return err
	}
	return strm.MsgSend(out)
}

type SRPCAccessVolumes_WatchVolumeInfoStream interface {
	srpc.Stream
}

type srpcAccessVolumes_WatchVolumeInfoStream struct {
	srpc.Stream
}
